import React, {useEffect, useLayoutEffect, useState} from "react"
import "./App.css"
import {
    Backdrop,
    Box,
    Button,
    Dialog, DialogContent, DialogContentText, DialogTitle,
    FormControl, IconButton,
    ImageList,
    ImageListItem,
    InputLabel, Link,
    List,
    ListItemText,
    MenuItem, Modal, Popover,
    Slider,
    Stack,
    TextField,
    Tooltip,
    Typography, useTheme
} from "@mui/material"
import Grid from "@mui/material/Unstable_Grid2"
import LoadingSpinner from "./LoadingSpinner"
import {Info, Brush, LineWeight, Close} from "@mui/icons-material"
import {MaskEditor, toMask} from "./MaskEditor.jsx"
import "./Imagen2.css"
import {Edit} from "@mui/icons-material/";
import {useDebounce} from "react-use";

const RaiReason = ({code}) =>  <Stack
    direction="row"
    justifyContent="center"
    alignItems="center"
    sx={{ width: 1, height: "100%" }}
>
    <Typography>Blocked. Reason code: {code}.</Typography>
</Stack>

const Predictions = ({predictions, handlePredictionOpen}) => {
    if (predictions.length <= 0) return
    return (
        <ImageList cols={2} sx={{mt:"4px", mb:0}}>
            {predictions.map((prediction, i) => {
                const dataUrl = `data:${prediction.mimeType};base64,${prediction.bytesBase64Encoded}`
                if (prediction.bytesBase64Encoded !== undefined) return (
                    <ImageListItem  key={i}>
                        <img src={dataUrl}
                             style={{maxWidth: "100%"}}
                             onClick={() => handlePredictionOpen(prediction)}
                             alt={`Generated by Imagen2: "${prompt}"`}
                        />
                    </ImageListItem>
                )

                if (prediction.raiFilteredReason !== undefined) return (
                    <ImageListItem sx={{aspectRatio: "1 / 1"}}   key={i}>
                        <RaiReason code={prediction.raiFilteredReason}/>
                    </ImageListItem>
                )
            })}
        </ImageList>
    )
}

const PredictionEditDialog = ({prediction, handleClose, handleEdit}) => {
    if (prediction === undefined
        || prediction.mimeType === undefined
        || prediction.bytesBase64Encoded === undefined) return

    if (!Boolean(prediction)) return

    const [hasMask, setHasMask] = useState(false)
    const [brushSizeOpen, setBrushSizeOpen] = useState(false)
    const [brushSize, setBrushSize] = useState(50)
    const [editPromptDialogOpen, setEditPromptDialogOpen] = useState(false)
    const [editPrompt, setEditPrompt] = useState("")
    const [editNegativePrompt, setEditNegativePrompt] = useState("")

    const theme = useTheme()

    const canvas = React.useRef()

    const dataUrl = `data:${prediction.mimeType};base64,${prediction.bytesBase64Encoded}`

    useDebounce(()=> {
        setBrushSizeOpen(false)
    }, 1500, [brushSize])

    const  submitEditPrompt = () => {
        const mask = toMask(canvas.current)
        handleEdit({
            baseImage: prediction,
            editPrompt,
            editNegativePrompt,
            maskDataUrl: mask.hasData ? mask.dataUrl : undefined,
        })
        handleClose()
    }

    const handleKeyDown = (e) => {
        if (e.keyCode !== 13) return
        if (e.shiftKey) return
        submitEditPrompt()
    }

    const EditPromptDialog = <Dialog open={editPromptDialogOpen}
                                     onClose={()=>setEditPromptDialogOpen(false)}
                                     autoFocus
                             >
        <DialogTitle>Edit Image</DialogTitle>
        <DialogContent>
            <Stack direction="column" spacing={2}>
                <DialogContentText>Type your edit instructions below. If you have drawn using the brush tool then your instructions will only be applied to that area, otherwise your prompt will apply to the whole image.</DialogContentText>
                <TextField label="Enter your prompt here"
                           variant="outlined"
                           fullWidth
                           autoFocus
                           multiline={true}
                           value={editPrompt}
                           error={editPrompt.length === 0}
                           onChange={e => setEditPrompt(e.target.value)}
                           helperText={editPrompt.length === 0 ? "Required" : undefined}
                           onKeyDown={handleKeyDown}
                />
                <TextField label="Negative prompt (optional)"
                           variant="outlined"
                           fullWidth
                           value={editNegativePrompt}
                           onChange={e => setEditNegativePrompt(e.target.value)}
                           onKeyDown={handleKeyDown}
                />
                <Button variant="contained"
                        fullWidth
                        onClick={()=>submitEditPrompt()}
                        disabled={editPrompt.length <= 0}
                >
                    Submit Prompt
                </Button>
            </Stack>
        </DialogContent>
    </Dialog>

    const EditToolTray = <Stack direction="row"
                                className="buttonTray"
                                sx={{backgroundColor: "rgba(255, 255, 255, 0.5)"}}
                                p={1}
    >
        <Tooltip title={!hasMask ? "Open Image Editing Tools" : "Close Image Editing Tools"} placement="bottom-end">
            <IconButton size="large"
                        color={hasMask ? "primary" : "default"}
                        onClick={() => setHasMask(!hasMask)}
            >
                {hasMask ? <Close/> : <Brush/>}
            </IconButton>
        </Tooltip>
        {hasMask && <>
            <Stack direction="column" spacing={0} maxHeight={300}>
                <Tooltip title="Brush Size" placement="bottom-end">
                    <IconButton size="large"
                                color={brushSizeOpen ? "primary" : "default"}
                                onClick={(e) => setBrushSizeOpen(Boolean(brushSizeOpen) ? undefined : e.currentTarget)}
                    >
                        <LineWeight/>
                    </IconButton>
                </Tooltip>
                <Popover open={Boolean(brushSizeOpen)}
                         onClose={() => setBrushSizeOpen(undefined)}
                         anchorEl={brushSizeOpen}
                         anchorOrigin={{
                             vertical: "bottom",
                             horizontal: "left",
                         }}
                >
                    <Stack height={300} width={48} my={3} spacing={3} alignItems="center">
                        <Typography>{brushSize}</Typography>
                        <Slider orientation="vertical"
                                defaultValue={30}
                                min={5}
                                max={250}
                                value={brushSize}
                                aria-label="Brush Size (px)"
                                onChange={(e) => setBrushSize(e.target.value)}
                        />
                    </Stack>
                </Popover>
            </Stack>
            <Tooltip title="Edit image with prompt" placement="bottom-end">
                <IconButton size="large"
                            color="primary"
                            onClick={()=>setEditPromptDialogOpen(true)}
                            sx={{
                                backgroundColor: "primary.main",
                                color: "white",
                                "&:hover": "primary.main",
                            }}
                >
                    <Edit/>
                </IconButton>
            </Tooltip>
        </>}
    </Stack>;

    const modalCloseFilter = (reason) => () => {
        if (reason && reason === "click" && hasMask) return
        handleClose()
    }

    return (<Dialog open={Boolean(prediction)}
                    fullScreen
                    onClick={modalCloseFilter("click")}
                    PaperProps={{sx: {backgroundColor: 'transparent'}}}
    >
        <div className="bounds-outer">
            <div className="bounds-inner">
                <div className="a" onClick={(e) => e.stopPropagation()}>
                    {!hasMask && <img src={dataUrl} className="imageOpen"/>}
                    {hasMask && <MaskEditor src={dataUrl}
                                            cursorSize={brushSize}
                                            canvasRef={canvas}
                                            maskColor={theme.palette.primary.main}
                                            maskBlendMode="hard-light"
                    />}
                    <Stack direction="row" className="buttonTray" sx={{backgroundColor: "rgba(255, 255, 255, 0.5)"}}>
                        {EditToolTray}
                        {EditPromptDialog}
                    </Stack>
                    <Tooltip title="Close Image" placement="bottom-end">
                        <IconButton size="large"
                                    color="primary"
                                    onClick={modalCloseFilter("close")}
                                    sx={{
                                        position: "absolute",
                                        top: 0,
                                        right: 0,
                                        zIndex: 100,
                                    }}
                        >
                            <Close/>
                        </IconButton>
                    </Tooltip>
                </div>
            </div>
        </div>
    </Dialog>)
}

function Imagen2() {
    const [history, setHistory] = useState([])
    const [loading, setLoading] = useState(false)
    const [prompt, setPrompt] = useState("")
    const [negativePrompt, setNegativePrompt] = useState("")
    const [guidanceScale, setGuidanceScale] = useState(10)
    const [language, setLanguage] = useState("auto")
    const [error, setError] = useState("")
    const [predictionOpen, setPredictionOpen] = useState("")

    const generateImages = async () => {
        if(prompt === "") return
        try {
            const np = negativePrompt.length > 0 ? negativePrompt : undefined
            const body = {
                instances: [{prompt}],
                parameters: {
                    negativePrompt: np,
                    guidanceScale,
                    language,
                    sampleCount: 4,
                    includeRaiReason: true,
                    includeSafetyAttributes: true,
                    disablePersonFace: false,
                    disableChild: false,
                }
            }
            const res = await fetch("/api/generate-image", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(body)
            })
            if (!res.ok) throw new Error(await res.text())
            history.unshift(await res.json())
            setHistory([...history])
            setLoading(false)
            window.scroll({
                top: 0,
                left: 0,
                behavior: 'smooth'
            })
        }
        catch(err){
            setError(err.message)
            setHistory([])
            setLoading(false)
        }
    }

    const handleEdit = async ({baseImage, editPrompt, editNegativePrompt, maskDataUrl}) => {
        if(editPrompt === "") return
        setLoading(true)
        setError("")
        window.scroll({
            top: 0,
            left: 0,
            behavior: 'smooth'
        })

       const mask = !maskDataUrl ? undefined : {image: {
            mimeType: maskDataUrl.split(";")[0].split(":")[1],
            bytesBase64Encoded: maskDataUrl.split(",")[1]
        }}
        
        try {
            const np = editNegativePrompt.length > 0 ? editNegativePrompt : undefined
            const body = {
                instances: [{
                    prompt: editPrompt,
                    image: {
                        bytesBase64Encoded: baseImage.bytesBase64Encoded,
                        mimeType: baseImage.mimeType
                    },
                    mask,
                }],
                parameters: {
                    negativePrompt: np,
                    guidanceScale,
                    language,
                    sampleCount: 4,
                    includeRaiReason: true,
                    includeSafetyAttributes: true,
                    disablePersonFace: false,
                    disableChild: false,
                }
            }

            const res = await fetch("/api/generate-image", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(body)
            })
            if (!res.ok) throw new Error(await res.text())
            history.unshift(await res.json())
            setHistory([...history])
            setLoading(false)
            window.scroll({
                top: 0,
                left: 0,
                behavior: 'smooth'
            })
        }
        catch(err){
            setError(err.message)
            setHistory([])
            setLoading(false)
        }
    }

    const onFormSubmit = async (e) => {
        e.preventDefault()
        setLoading(true)
        setError("")
        return generateImages()
    }

    const guidanceTooltip = () => {
        return (
            <>
                <Typography variant="h6">How strong do you want the prompt(s) to be?</Typography>
                <Typography>
                    A larger number will make an image that is closer to your prompt(s),
                    a smaller number will result in a more creative image.
                </Typography>
                <Typography variant="h6">Suggested values</Typography>
                <List>
                    <ListItemText>0-9: low strength</ListItemText>
                    <ListItemText>10-20: medium strength</ListItemText>
                    <ListItemText>21 or higher: high strength</ListItemText>
                </List>
            </>
        )
    }

    const guidanceScaleColor = (g) => {
        if (g <= 9) return "success"
        else if (g <= 20 ) return "warning"
        else return "error"
    }

    const guidanceScaleSuffix = (g) => {
        if (g <= 9) return `${g} (low)`
        else if (g <= 20 ) return `${g} (medium)`
        else return `${g} (high)`
    }

    const handlePredictionOpen = (prediction) => {
        setPredictionOpen(prediction)
    }

    return (
        <form>
        <Grid container spacing={2}>
            <Grid xs={12} md={10}>
                <TextField label="Enter your prompt here"
                           variant="outlined"
                           fullWidth
                           value={prompt}
                           error={prompt.length === 0}
                           onChange={e => setPrompt(e.target.value)}
                           helperText={prompt.length === 0 ? "Required" : undefined}
                />
            </Grid>

            <Grid xs={12} md={2}>
                <TextField label="Language"
                           select
                           fullWidth
                           value={language}
                           onChange={e => setLanguage(e.target.value)}
                >
                    <MenuItem value="auto">(auto)</MenuItem>
                    <MenuItem value="en">English</MenuItem>
                    <MenuItem value="es">Spanish</MenuItem>
                    <MenuItem value="hi">Hindi</MenuItem>
                    <MenuItem value="ja">Japanese</MenuItem>
                    <MenuItem value="ko">Korean</MenuItem>
                    <MenuItem value="pt">Portuguese</MenuItem>
                    <MenuItem value="zh-TW">Chinese (traditional)</MenuItem>
                    <MenuItem value="zh-CN">Chinese (simplified)</MenuItem>
                </TextField>
            </Grid>

            <Grid xs={12} md={10}>
                <TextField label="Negative prompt (optional)"
                           variant="outlined"
                           fullWidth
                           value={negativePrompt}
                           onChange={e => setNegativePrompt(e.target.value)}
                />
            </Grid>

            {import.meta.env.PROMPT_GUIDE_LINK &&
                <Grid xs={12} md={2}>
                    <Typography>
                        <Link href={import.meta.env.PROMPT_GUIDE_LINK} target="_blank">View Prompting Guide</Link>
                    </Typography>
                </Grid>
            }

            <Grid xs={12}>
                <Stack spacing={2}
                       direction="row"
                       sx={{ mb: 1 }}
                       alignItems="center">
                    <FormControl fullWidth>
                        <InputLabel id="strength-slider">Prompt strength</InputLabel>
                        <Slider min={0}
                                max={30}
                                value={guidanceScale}
                                aria-labelledby="strength-slider"
                                valueLabelDisplay="auto"
                                onChange={e => setGuidanceScale(e.target.value)}
                                color={guidanceScaleColor(guidanceScale)}
                                getAriaValueText={guidanceScaleSuffix}
                                valueLabelFormat={guidanceScaleSuffix}
                        />
                    </FormControl>
                     <Tooltip title={guidanceTooltip()}><Info/></Tooltip>
                </Stack>
            </Grid>

            <Grid xs={12} md={4}>
                <Button onClick={onFormSubmit}
                        type="submit"
                        size="large"
                        variant="contained"
                        disabled={prompt.length <= 0 || loading}
                        endIcon={loading?<LoadingSpinner/>:<Brush/>}
                        fullWidth
                >
                    Generate Images
                </Button>
            </Grid>

            <Grid xs={12} spacing={0}>
                {history.map((predictions, i) => <Predictions key={i} {...{predictions, handlePredictionOpen}}/>)}
                <PredictionEditDialog prediction={predictionOpen}
                                      handleClose={()=>setPredictionOpen("")}
                                      handleEdit={handleEdit}
                />
            </Grid>

            <Grid xs={12}>
                {error.length > 0 && !loading &&
                    <Typography sx={{whiteSpace: 'pre-line', fontFamily: 'Monospace', color: 'error.main'}}>
                        {error}
                    </Typography>
                }
            </Grid>
        </Grid>
        </form>
    )
}

export default Imagen2
