import {useState, useRef, useEffect} from "react"
import "./App.css"
import {
  Button, Checkbox,
  FormControl, FormControlLabel,
  ImageList,
  ImageListItem,
  InputLabel,
  List,
  ListItemText,
  MenuItem,
  Slider,
  Stack,
  TextField,
  Tooltip,
  Typography
} from "@mui/material"
import Grid from "@mui/material/Unstable_Grid2"
import LoadingSpinner from "./LoadingSpinner"
import {Brush, Info, Upload, ClearAll, Draw} from "@mui/icons-material"
import "./Imagen2.css"
import PropTypes from "prop-types"
import {ImageEditDialog} from "./ImageEditDialog.jsx"
import {useDebounce} from "react-use"
import {useLocation, useNavigate} from "react-router-dom"
import {Buffer} from "buffer/"
import setupIndexedDB, { useIndexedDBStore } from "use-indexeddb"
import ScribbleDialog from "./ScribbleDialog.jsx"

const idbConfig = {
  databaseName: "imagen2-db",
  version: 1,
  stores: [
    {
      name: "state",
      id: { keyPath: "route" },
      indices: [],
    },
    {
      name: "history",
      id: { keyPath: "id", autoIncrement: true },
      indices: [],
    },
  ],
}

const RaiReason = ({code}) =>  <Stack
  direction="row"
  justifyContent="center"
  alignItems="center"
  sx={{ width: 1, height: "100%" }}
>
  <Typography>Blocked. Reason code: {code}.</Typography>
</Stack>
RaiReason.propTypes = {
  code: PropTypes.string,
}

const Predictions = ({predictions, handlePredictionOpen}) => {
  if (predictions.length <= 0) return
  return (
    <ImageList cols={2} sx={{mt:"4px", mb:0}}>
      {predictions.map((prediction, i) => {
        const dataUrl = `data:${prediction.mimeType};base64,${prediction.bytesBase64Encoded}`
        if (prediction.bytesBase64Encoded !== undefined) return (
          <ImageListItem key={i}>
            <img src={dataUrl}
                 style={{maxWidth: "100%"}}
                 onClick={() => handlePredictionOpen(prediction)}
                 alt={`Generated by Imagen2: "${prompt}"`}
            />
          </ImageListItem>
        )

        if (prediction.raiFilteredReason !== undefined) return (
          <ImageListItem sx={{aspectRatio: "1 / 1"}}   key={i}>
            <RaiReason code={prediction.raiFilteredReason}/>
          </ImageListItem>
        )
      })}
    </ImageList>
  )
}
Predictions.propTypes = {
  predictions: PropTypes.array,
  handlePredictionOpen: PropTypes.func,
}

function Imagen2() {
  const [loadingState , setLoadingState] = useState(false)
  const [history, setHistory] = useState([])
  const [loading, setLoading] = useState(false)
  const [prompt, setPrompt] = useState("")
  const [negativePrompt, setNegativePrompt] = useState("")
  const [guidanceScale, setGuidanceScale] = useState(60)
  const [language, setLanguage] = useState("auto")
  const [error, setError] = useState(null)
  const [predictionOpen, setPredictionOpen] = useState("")
  const [fast, setFast] = useState(false)
  const [scribbleOpen, setScribbleOpen] = useState(false)
  const fileInputRef = useRef(null)
 
  const {update: updatePersistedState, getByID: getPersistedState} = useIndexedDBStore("state")
  const {update: updatePersistedHistory, getAll: getPersistedHistory} = useIndexedDBStore("history")

  const {pathname} = useLocation()
  const navigate = useNavigate()

  useEffect(() => {setupIndexedDB(idbConfig)}, [])

  const [,] = useDebounce(
    () => {
      updatePersistedState({route: "imagen", state: serialiseState()})
      console.log(history)
      history.slice(0, 10).forEach((history, id) => updatePersistedHistory({id, history}))
    },
    1000,
    [
      history,
      prompt,
      negativePrompt,
      guidanceScale,
      language,
      fast,
    ]
  )
  const serialiseState = () => {
    return Buffer.from(JSON.stringify({
      prompt,
      negativePrompt,
      guidanceScale,
      language,
      fast,
    })).toString('base64')
  }
  useEffect(() => {
    async function loadState() {
      setLoadingState(true)
      try {
        const {state} = await getPersistedState("imagen")
        if (state !== undefined) {
          const j = JSON.parse(Buffer.from(state, "base64").toString())
          setPrompt(j.prompt ?? "")
          setNegativePrompt(j.negativePrompt ?? "")
          setGuidanceScale(j.guidanceScale ?? 60)
          setLanguage(j.language ?? "auto")
          setFast(j.fast ?? false)
        }

        const persistedHistory = await getPersistedHistory()
        console.log(persistedHistory)
        if (persistedHistory.length > 0) { 
          setHistory(persistedHistory.map(h => h.history))
        }
      }
      finally {
        setLoadingState(false)
      }
    }
    loadState()
  }, [navigate, pathname, getPersistedState, getPersistedHistory]
  )

  const callApi = async (body) => {
    const res = await fetch("/api/generate-image", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    })
    if (!res.ok) throw new Error(await res.text())
    const newItem = await res.json()
    setHistory([newItem, ...history])
    setLoading(false)
    window.scroll({
      top: 0,
      left: 0,
      behavior: 'smooth'
    })
  }

  const generateImages = async () => {
    if(prompt === "") return
    try {
      const np = negativePrompt.length > 0 ? negativePrompt : undefined
      const body = {
        instances: [{prompt}],
        parameters: {
          negativePrompt: np,
          guidanceScale,
          language,
          sampleCount: 4,
          includeRaiReason: true,
          includeSafetyAttributes: true,
          personGeneration: "allow_all",
          safetySetting: "block_low_and_above",
        },
        fast
      }
      await callApi(body)
    }
    catch(err){
      console.error(err, err.stack)
      setError(err)
      //setHistory([])
      setLoading(false)
    }
  }

  const resizeImage = (baseImage, {width, height}) => {
    const canvas = document.createElement('canvas'),
    ctx = canvas.getContext('2d'),
    image = new Image()
    
    return new Promise((resolve) => {
      image.onload = () => {
        canvas.width = width
        canvas.height = height
        ctx.drawImage(image, 0, 0, width, height)
        const dataUrl = canvas.toDataURL('image/png', 1.0)
        resolve(parseDataUrl(dataUrl))
      }
      image.src = `data:${baseImage.mimeType};base64,${baseImage.bytesBase64Encoded}`
    })
  }

  const handleEdit = async ({baseImage, editMode, maskType, maskClasses, editPrompt, editNegativePrompt, maskDataUrl}) => {
    setPredictionOpen(false)
    setLoading(true)
    setError(null)
    window.scroll({
      top: 0,
      left: 0,
      behavior: 'smooth'
    })

    const maskImage = !maskDataUrl ? undefined : {
      mimeType: maskDataUrl.split(";")[0].split(":")[1],
      bytesBase64Encoded: maskDataUrl.split(",")[1]
    }

    const referenceImages = [
      { 
        referenceId: 1,
        referenceType: "REFERENCE_TYPE_RAW", 
        referenceImage: {bytesBase64Encoded: baseImage.bytesBase64Encoded, mimeType: baseImage.mimeType},
      }
    ]

    const maskMode = editMode === "EDIT_MODE_BGSWAP" ? "MASK_MODE_BACKGROUND" : 
                     editMode === "EDIT_MODE_OUTPAINT" ? "MASK_MODE_USER_PROVIDED" :
                     maskType
    const maskDilation = (editMode === "EDIT_MODE_INPAINT_INSERTION"  || editMode === "EDIT_MODE_REMOVAL") ? 0.01 :
                          editMode === "EDIT_MODE_BGSWAP" ? 0.0 : 
                          0.02  

    const maskConfig = {
      referenceId: 2, 
      referenceType: "REFERENCE_TYPE_MASK", 
      maskImageConfig: {
        maskMode, 
        maskDilation,
      }
    }

    if (maskImage && editMode !== "EDIT_MODE_BGSWAP" && maskMode === "MASK_MODE_USER_PROVIDED") {
       maskConfig.referenceImage = {bytesBase64Encoded: maskImage.bytesBase64Encoded, mimeType: maskImage.mimeType}
    }

    if (maskMode === "MASK_MODE_SEMANTIC") maskConfig.maskImageConfig.maskClasses = maskClasses.map(c => c.key)

    if (editMode !== "EDIT_MODE_DEFAULT") referenceImages.push(maskConfig)
    
    try {
      const np = editNegativePrompt.length > 0 ? editNegativePrompt : undefined
      const body = {
        instances: [{
          prompt: editMode === "EDIT_MODE_INPAINT_REMOVAL" ? "" : editPrompt,
          referenceImages,
        }],
        parameters: {
          editMode,
          negativePrompt: np,
          guidanceScale,
          language,
          sampleCount: 4,
          includeRaiReason: true,
          includeSafetyAttributes: true,
          disablePersonFace: false,
          disableChild: false,
          safetySetting: "block_low_and_above",
          personGeneration: "allow_all",
        }
      }
      await callApi(body)
    }
    catch(err){
      console.error(err, err.stack)
      setError(err)
      //setHistory([])
      setLoading(false)
    }
  }

  const handleScribble = async ({scribbleDataUrl, scribblePrompt, scribbleNegativePrompt}) => {
    setLoading(true)
    setScribbleOpen(false)
    setError(null)
    const np = scribbleNegativePrompt.length > 0 ? scribbleNegativePrompt : undefined
    const body = {
      instances: [{
        prompt: scribblePrompt,
        referenceImages: [{
          referenceId: 1,
          referenceType: "REFERENCE_TYPE_CONTROL",
          referenceImage: parseDataUrl(scribbleDataUrl),
          controlImageConfig: {
            controlType: "CONTROL_TYPE_SCRIBBLE",
            enableControlImageComputation: false,
          }
        }],
      }],
      parameters: {
        editMode: "EDIT_MODE_CONTROLLED_EDITING",
        negativePrompt: np,
        guidanceScale,
        language,
        sampleCount: 4,
        includeRaiReason: true,
        includeSafetyAttributes: true,
        disablePersonFace: false,
        disableChild: false,
        safetySetting: "block_low_and_above",
        personGeneration: "allow_all",
      }
    }
    await callApi(body)
  }

  const onFormSubmit = async (e) => {
    e.preventDefault()
    setLoading(true)
    setError(null)
    return generateImages()
  }

  const guidanceTooltip = () => {
    return (
      <>
        <Typography variant="h6">How strong do you want the prompt(s) to be?</Typography>
        <Typography>
          A larger number will make an image that is closer to your prompt(s),
          a smaller number will result in a more creative image.
        </Typography>
        <Typography variant="h6">Suggested values</Typography>
        <List>
          <ListItemText>0-120: low strength</ListItemText>
          <ListItemText>121-250: medium strength</ListItemText>
          <ListItemText>251 or higher: high strength</ListItemText>
        </List>
      </>
    )
  }

  const guidanceScaleColor = (g) => {
    if (g <= 120) return "success"
    else if (g <= 250 ) return "warning"
    else return "error"
  }

  const guidanceScaleSuffix = (g) => {
    if (g <= 120) return `${g} (low)`
    else if (g <= 250 ) return `${g} (medium)`
    else return `${g} (high)`
  }

  const handlePredictionOpen = (prediction) => {
    setPredictionOpen(prediction)
  }

  const handleImageUpload = async (event) => {
    const file = event.target.files[0]
    if (!file) return

    try {
      setLoading(true)
      setError(null)

      const reader = new FileReader()
      reader.onload = async (e) => {
        const image = parseDataUrl(e.target.result)
        const resizedImage = await resizeImage(image, {width: 1024, height: 1024})
        setHistory([[resizedImage], ...history])
      }
      reader.readAsDataURL(file)
    } catch (err) {
      console.error(err, err.stack)
      setError(err)
    } finally {
      setLoading(false)
      if (fileInputRef.current) {
        fileInputRef.current.value = ''
      }
    }
  }

  const clearAll = () => {
    setHistory([])
    setPrompt("")
    setNegativePrompt("")
    setGuidanceScale(60)
    setLanguage("auto")
    setFast(false)
  }

  return (
    loadingState ? <LoadingSpinner/> :
    <form>
      <Grid container spacing={2}>
        <Grid xs={12} md={10}>
          <TextField label="Enter your prompt here"
                     variant="outlined"
                     fullWidth
                     value={prompt}
                     error={prompt.length === 0}
                     onChange={e => setPrompt(e.target.value)}
                     helperText={prompt.length === 0 ? "Required" : undefined}
          />
        </Grid>

        <Grid xs={12} md={2}>
          <TextField label="Language"
                     select
                     fullWidth
                     value={language}
                     onChange={e => setLanguage(e.target.value)}
          >
            <MenuItem value="auto">(auto)</MenuItem>
            <MenuItem value="en">English</MenuItem>
            <MenuItem value="es">Spanish</MenuItem>
            <MenuItem value="hi">Hindi</MenuItem>
            <MenuItem value="ja">Japanese</MenuItem>
            <MenuItem value="ko">Korean</MenuItem>
            <MenuItem value="pt">Portuguese</MenuItem>
            <MenuItem value="zh-TW">Chinese (traditional)</MenuItem>
            <MenuItem value="zh-CN">Chinese (simplified)</MenuItem>
          </TextField>
        </Grid>

        <Grid xs={12} md={10}>
          <TextField label="Negative prompt (optional)"
                     variant="outlined"
                     fullWidth
                     value={negativePrompt}
                     onChange={e => setNegativePrompt(e.target.value)}
          />
        </Grid>

        <Grid xs={12} md={2} sx={{justifyContent: "center", display: "flex", flexDirection: "column"}} >
          <FormControlLabel control={<Checkbox value={fast} onChange={e => setFast(e.target.checked)}/>} label="Fast?" />
        </Grid>


        <Grid xs={12}>
          <Stack spacing={2}
                 direction="row"
                 sx={{ mb: 1 }}
                 alignItems="center">
            <FormControl fullWidth>
              <InputLabel id="strength-slider">Prompt strength</InputLabel>
              <Slider min={0}
                      max={500}
                      value={guidanceScale}
                      aria-labelledby="strength-slider"
                      valueLabelDisplay="auto"
                      onChange={e => setGuidanceScale(e.target.value)}
                      color={guidanceScaleColor(guidanceScale)}
                      getAriaValueText={guidanceScaleSuffix}
                      valueLabelFormat={guidanceScaleSuffix}
              />
            </FormControl>
            <Tooltip title={guidanceTooltip()}><Info/></Tooltip>
          </Stack>
        </Grid>

        <Grid xs={12} md={6}>
          <Stack direction="row" spacing={2}>
            <Button onClick={onFormSubmit}
                    type="submit"
                    size="large"
                    variant="contained"
                    disabled={prompt.length <= 0 || loading}
                    endIcon={loading?<LoadingSpinner/>:<Brush/>}
                    sx={{pr:2, pl:2}}
            >
              Generate Images
            </Button>
            <input
              type="file"
              accept="image/*"
              style={{ display: 'none' }}
              ref={fileInputRef}
              onChange={handleImageUpload}
            />
            <Button
              onClick={() => fileInputRef.current?.click()}
              size="large"
              variant="outlined"
              disabled={loading}
              endIcon={<Upload/>}
              sx={{pr:2, pl:2}}
            >
              Upload
            </Button>
            <Button
              onClick={() => setScribbleOpen(true)}
              size="large"
              variant="outlined"
              disabled={loading}
              endIcon={<Draw/>}
              sx={{pr:2, pl:2}}
            >
              Scribble
            </Button>
            <Button onClick={clearAll}
                  size="large"
                  variant="outlined"
                  sx={{pr:2, pl:2}}
                  disabled={loading}
                  endIcon={<ClearAll/>}                  
            >
              Clear All
            </Button>
          </Stack>
        </Grid>

        <Grid xs={12}>
          {error !== null && !loading &&
            <Typography sx={{whiteSpace: 'pre-line', fontFamily: 'Monospace', color: 'error.main'}}>
              {error.toString()}
            </Typography>
          }
        </Grid>

        <Grid xs={12} spacing={0}>
          {history.map((predictions, i) => <Predictions key={i} {...{predictions, handlePredictionOpen}}/>)}
          <ImageEditDialog prediction={predictionOpen}
                           handleClose={()=>setPredictionOpen("")}
                           handleEdit={handleEdit}
          />
          <ScribbleDialog
            open={scribbleOpen}
            handleClose={() => setScribbleOpen(false)}
            handleScribble={handleScribble}
          />
        </Grid> 
      </Grid>
    </form>
  )
}

function parseDataUrl(dataUrl) {
  return {
    mimeType: dataUrl.split(";")[0].split(":")[1],
    bytesBase64Encoded: dataUrl.split(",")[1]
  }
}

export default Imagen2
